{"ast":null,"code":"import * as t from \"leaflet\";\nimport { Control as e, Icon as r, FeatureGroup as n, DomEvent as o, Marker as s, LatLngBounds as i, LatLng as a } from \"leaflet\";\n\nfunction u() {\n  return (u = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction l(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction c(t, e) {\n  return (c = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction h() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction p(t, e, r) {\n  return (p = h() ? Reflect.construct : function (t, e, r) {\n    var n = [null];\n    n.push.apply(n, e);\n    var o = new (Function.bind.apply(t, n))();\n    return r && c(o, r.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction f(t, e, r, n) {\n  void 0 === e && (e = \"\"), void 0 === n && (n = {});\n  var o = document.createElement(t);\n  return e && (o.className = e), Object.keys(n).forEach(function (t) {\n    if (\"function\" == typeof n[t]) {\n      var e = 0 === t.indexOf(\"on\") ? t.substr(2).toLowerCase() : t;\n      o.addEventListener(e, n[t]);\n    } else \"html\" === t ? o.innerHTML = n[t] : \"text\" === t ? o.innerText = n[t] : o.setAttribute(t, n[t]);\n  }), r && r.appendChild(o), o;\n}\n\nfunction d(t) {\n  t.preventDefault(), t.stopPropagation();\n}\n\nvar m = function () {\n  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];\n\n  return e.filter(Boolean).join(\" \").trim();\n};\n\nfunction v(t, e) {\n  t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {\n    t.classList.contains(e) || t.classList.add(e);\n  });\n}\n\nfunction y(t, e) {\n  t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {\n    t.classList.contains(e) && t.classList.remove(e);\n  });\n}\n\nvar g,\n    b = 13,\n    x = 40,\n    E = 38,\n    w = [b, 27, x, E, 37, 39],\n    L = function () {\n  function t(t) {\n    var e = this,\n        r = t.handleSubmit,\n        n = t.searchLabel,\n        o = t.classNames,\n        s = void 0 === o ? {} : o;\n    this.hasError = !1, this.container = f(\"div\", m(\"geosearch\", s.container)), this.form = f(\"form\", [\"\", s.form].join(\" \"), this.container, {\n      autocomplete: \"none\",\n      onClick: d,\n      onDblClick: d,\n      touchStart: d,\n      touchEnd: d\n    }), this.input = f(\"input\", [\"glass\", s.input].join(\" \"), this.form, {\n      type: \"text\",\n      placeholder: n || \"search\",\n      onInput: this.onInput,\n      onKeyUp: function (t) {\n        return e.onKeyUp(t);\n      },\n      onKeyPress: function (t) {\n        return e.onKeyPress(t);\n      },\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onClick: function () {\n        e.input.focus(), e.input.dispatchEvent(new Event(\"focus\"));\n      }\n    }), this.handleSubmit = r;\n  }\n\n  var e = t.prototype;\n  return e.onFocus = function () {\n    v(this.form, \"active\");\n  }, e.onBlur = function () {\n    y(this.form, \"active\");\n  }, e.onSubmit = function (t) {\n    try {\n      var e = this;\n      return d(t), y(r = e.container, \"error\"), v(r, \"pending\"), Promise.resolve(e.handleSubmit({\n        query: e.input.value\n      })).then(function () {\n        y(e.container, \"pending\");\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n\n    var r;\n  }, e.onInput = function () {\n    this.hasError && (y(this.container, \"error\"), this.hasError = !1);\n  }, e.onKeyUp = function (t) {\n    27 === t.keyCode && (y(this.container, [\"pending\", \"active\"]), this.input.value = \"\", document.body.focus(), document.body.blur());\n  }, e.onKeyPress = function (t) {\n    t.keyCode === b && this.onSubmit(t);\n  }, e.setQuery = function (t) {\n    this.input.value = t;\n  }, t;\n}(),\n    k = function () {\n  function t(t) {\n    var e = this,\n        r = t.handleClick,\n        n = t.classNames,\n        o = void 0 === n ? {} : n,\n        s = t.notFoundMessage;\n    this.selected = -1, this.results = [], this.onClick = function (t) {\n      if (\"function\" == typeof e.handleClick) {\n        var r = t.target;\n\n        if (r && e.container.contains(r) && r.hasAttribute(\"data-key\")) {\n          var n = Number(r.getAttribute(\"data-key\"));\n          e.clear(), e.handleClick({\n            result: e.results[n]\n          });\n        }\n      }\n    }, this.handleClick = r, this.notFoundMessage = s ? f(\"div\", m(o.notfound), void 0, {\n      html: s\n    }) : void 0, this.container = f(\"div\", m(\"results\", o.resultlist)), this.container.addEventListener(\"click\", this.onClick, !0), this.resultItem = f(\"div\", m(o.item));\n  }\n\n  var e = t.prototype;\n  return e.render = function (t, e) {\n    var r = this;\n    void 0 === t && (t = []), this.clear(), t.forEach(function (t, n) {\n      var o = r.resultItem.cloneNode(!0);\n      o.setAttribute(\"data-key\", \"\" + n), o.innerHTML = e({\n        result: t\n      }), r.container.appendChild(o);\n    }), t.length > 0 ? (v(this.container.parentElement, \"open\"), v(this.container, \"active\")) : this.notFoundMessage && (this.container.appendChild(this.notFoundMessage), v(this.container.parentElement, \"open\")), this.results = t;\n  }, e.select = function (t) {\n    return Array.from(this.container.children).forEach(function (e, r) {\n      return r === t ? v(e, \"active\") : y(e, \"active\");\n    }), this.selected = t, this.results[t];\n  }, e.count = function () {\n    return this.results ? this.results.length : 0;\n  }, e.clear = function () {\n    for (this.selected = -1; this.container.lastChild;) this.container.removeChild(this.container.lastChild);\n\n    y(this.container.parentElement, \"open\"), y(this.container, \"active\");\n  }, t;\n}(),\n    C = {\n  position: \"topleft\",\n  style: \"button\",\n  showMarker: !0,\n  showPopup: !1,\n  popupFormat: function (t) {\n    return \"\" + t.result.label;\n  },\n  resultFormat: function (t) {\n    return \"\" + t.result.label;\n  },\n  marker: {\n    icon: t && r ? new r.Default() : void 0,\n    draggable: !1\n  },\n  maxMarkers: 1,\n  maxSuggestions: 5,\n  retainZoomLevel: !1,\n  animateZoom: !0,\n  searchLabel: \"Enter address\",\n  notFoundMessage: \"\",\n  messageHideDelay: 3e3,\n  zoomLevel: 18,\n  classNames: {\n    container: \"leaflet-bar leaflet-control leaflet-control-geosearch\",\n    button: \"leaflet-bar-part leaflet-bar-part-single\",\n    resetButton: \"reset\",\n    msgbox: \"leaflet-bar message\",\n    form: \"\",\n    input: \"\",\n    resultlist: \"\",\n    item: \"\",\n    notfound: \"leaflet-bar-notfound\"\n  },\n  autoComplete: !0,\n  autoCompleteDelay: 250,\n  autoClose: !1,\n  keepResult: !1,\n  updateMap: !0\n},\n    U = \"Leaflet must be loaded before instantiating the GeoSearch control\",\n    P = {\n  options: u({}, C),\n  classNames: u({}, C.classNames),\n  initialize: function (e) {\n    var r,\n        s,\n        i,\n        a,\n        l = this;\n    if (!t) throw new Error(U);\n    if (!e.provider) throw new Error(\"Provider is missing from options\");\n    this.options = u({}, this.options, {}, e), this.classNames = u({}, this.classNames, {}, e.classNames), this.markers = new n(), this.classNames.container += \" leaflet-geosearch-\" + this.options.style, this.searchElement = new L({\n      searchLabel: this.options.searchLabel,\n      classNames: {\n        container: this.classNames.container,\n        form: this.classNames.form,\n        input: this.classNames.input\n      },\n      handleSubmit: function (t) {\n        return l.onSubmit(t);\n      }\n    }), this.button = f(\"a\", this.classNames.button, this.searchElement.container, {\n      title: this.options.searchLabel,\n      href: \"#\",\n      onClick: function (t) {\n        return l.onClick(t);\n      }\n    }), o.disableClickPropagation(this.button), this.resetButton = f(\"a\", this.classNames.resetButton, this.searchElement.form, {\n      text: \"Ã—\",\n      href: \"#\",\n      onClick: function () {\n        return l.clearResults(null, !0);\n      }\n    }), o.disableClickPropagation(this.resetButton), this.options.autoComplete && (this.resultList = new k({\n      handleClick: function (t) {\n        var e = t.result;\n        l.searchElement.input.value = e.label, l.onSubmit({\n          query: e.label,\n          data: e\n        });\n      },\n      classNames: {\n        resultlist: this.classNames.resultlist,\n        item: this.classNames.item,\n        notfound: this.classNames.notfound\n      },\n      notFoundMessage: this.options.notFoundMessage\n    }), this.searchElement.form.appendChild(this.resultList.container), this.searchElement.input.addEventListener(\"keyup\", (r = function (t) {\n      return l.autoSearch(t);\n    }, void 0 === (s = this.options.autoCompleteDelay) && (s = 250), void 0 === i && (i = !1), function () {\n      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];\n\n      a && clearTimeout(a), a = setTimeout(function () {\n        a = null, i || r.apply(void 0, e);\n      }, s), i && !a && r.apply(void 0, e);\n    }), !0), this.searchElement.input.addEventListener(\"keydown\", function (t) {\n      return l.selectResult(t);\n    }, !0), this.searchElement.input.addEventListener(\"keydown\", function (t) {\n      return l.clearResults(t, !0);\n    }, !0)), this.searchElement.form.addEventListener(\"click\", function (t) {\n      t.preventDefault();\n    }, !1);\n  },\n  onAdd: function (t) {\n    var e = this.options,\n        r = e.showMarker,\n        n = e.style;\n\n    if (this.map = t, r && this.markers.addTo(t), \"bar\" === n) {\n      var s = t.getContainer().querySelector(\".leaflet-control-container\");\n      this.container = f(\"div\", \"leaflet-control-geosearch leaflet-geosearch-bar\"), this.container.appendChild(this.searchElement.form), s.appendChild(this.container);\n    }\n\n    return o.disableClickPropagation(this.searchElement.form), this.searchElement.container;\n  },\n  onRemove: function () {\n    var t;\n    return null == (t = this.container) || t.remove(), this;\n  },\n  onClick: function (t) {\n    t.preventDefault(), t.stopPropagation();\n    var e = this.searchElement,\n        r = e.container,\n        n = e.input;\n    r.classList.contains(\"active\") ? (y(r, \"active\"), this.clearResults()) : (v(r, \"active\"), n.focus());\n  },\n  selectResult: function (t) {\n    if (-1 !== [b, x, E].indexOf(t.keyCode)) if (t.preventDefault(), t.keyCode !== b) {\n      var e = this.resultList.count() - 1;\n\n      if (!(e < 0)) {\n        var r = this.resultList.selected,\n            n = t.keyCode === x ? r + 1 : r - 1,\n            o = this.resultList.select(n < 0 ? e : n > e ? 0 : n);\n        this.searchElement.input.value = o.label;\n      }\n    } else {\n      var s = this.resultList.select(this.resultList.selected);\n      this.onSubmit({\n        query: this.searchElement.input.value,\n        data: s\n      });\n    }\n  },\n  clearResults: function (t, e) {\n    if (void 0 === e && (e = !1), !t || 27 === t.keyCode) {\n      var r = this.options,\n          n = r.autoComplete;\n      !e && r.keepResult || (this.searchElement.input.value = \"\", this.markers.clearLayers()), n && this.resultList.clear();\n    }\n  },\n  autoSearch: function (t) {\n    try {\n      var e = this;\n      if (w.indexOf(t.keyCode) > -1) return Promise.resolve();\n\n      var r = t.target.value,\n          n = e.options.provider,\n          o = function () {\n        if (r.length) return Promise.resolve(n.search({\n          query: r\n        })).then(function (t) {\n          t = t.slice(0, e.options.maxSuggestions), e.resultList.render(t, e.options.resultFormat);\n        });\n        e.resultList.clear();\n      }();\n\n      return Promise.resolve(o && o.then ? o.then(function () {}) : void 0);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  },\n  onSubmit: function (t) {\n    try {\n      var e = this;\n      return Promise.resolve(e.options.provider.search(t)).then(function (r) {\n        r && r.length > 0 && e.showResult(r[0], t);\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  },\n  showResult: function (t, e) {\n    var r = this.options,\n        n = r.autoClose,\n        o = r.updateMap,\n        s = this.markers.getLayers();\n    s.length >= this.options.maxMarkers && this.markers.removeLayer(s[0]);\n    var i = this.addMarker(t, e);\n    o && this.centerMap(t), this.map.fireEvent(\"geosearch/showlocation\", {\n      location: t,\n      marker: i\n    }), n && this.closeResults();\n  },\n  closeResults: function () {\n    var t = this.searchElement.container;\n    t.classList.contains(\"active\") && y(t, \"active\"), this.clearResults();\n  },\n  addMarker: function (t, e) {\n    var r = this,\n        n = this.options,\n        o = n.marker,\n        i = n.showPopup,\n        a = n.popupFormat,\n        u = new s([t.y, t.x], o),\n        l = t.label;\n    return \"function\" == typeof a && (l = a({\n      query: e,\n      result: t\n    })), u.bindPopup(l), this.markers.addLayer(u), i && u.openPopup(), o.draggable && u.on(\"dragend\", function (t) {\n      r.map.fireEvent(\"geosearch/marker/dragend\", {\n        location: u.getLatLng(),\n        event: t\n      });\n    }), u;\n  },\n  centerMap: function (t) {\n    var e = this.options,\n        r = e.retainZoomLevel,\n        n = e.animateZoom,\n        o = t.bounds ? new i(t.bounds) : new a(t.y, t.x).toBounds(10),\n        s = o.isValid() ? o : this.markers.getBounds();\n    !r && o.isValid() && !t.bounds || r || !o.isValid() ? this.map.setView(s.getCenter(), this.getZoom(), {\n      animate: n\n    }) : this.map.fitBounds(s, {\n      animate: n\n    });\n  },\n  getZoom: function () {\n    var t = this.options,\n        e = t.zoomLevel;\n    return t.retainZoomLevel ? this.map.getZoom() : e;\n  }\n};\n\nfunction R() {\n  if (!t) throw new Error(U);\n\n  for (var r = e.extend(P), n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n\n  return p(r, o);\n}\n\n!function (t) {\n  t[t.SEARCH = 0] = \"SEARCH\", t[t.REVERSE = 1] = \"REVERSE\";\n}(g || (g = {}));\n\nvar S = function () {\n  function t(t) {\n    void 0 === t && (t = {}), this.options = t;\n  }\n\n  var e = t.prototype;\n  return e.getParamString = function (t) {\n    void 0 === t && (t = {});\n    var e = u({}, this.options.params, {}, t);\n    return Object.keys(e).map(function (t) {\n      return encodeURIComponent(t) + \"=\" + encodeURIComponent(e[t]);\n    }).join(\"&\");\n  }, e.getUrl = function (t, e) {\n    return t + \"?\" + this.getParamString(e);\n  }, e.search = function (t) {\n    try {\n      var e = this,\n          r = e.endpoint({\n        query: t.query,\n        type: g.SEARCH\n      });\n      return Promise.resolve(fetch(r)).then(function (t) {\n        return Promise.resolve(t.json()).then(function (t) {\n          return e.parse({\n            data: t\n          });\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, t;\n}(),\n    j = function (t) {\n  function e() {\n    return t.apply(this, arguments) || this;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function () {\n    return \"https://places-dsn.algolia.net/1/places/query\";\n  }, r.findBestMatchLevelIndex = function (t) {\n    var e = t.find(function (t) {\n      return \"full\" === t.matchLevel;\n    }) || t.find(function (t) {\n      return \"partial\" === t.matchLevel;\n    });\n    return e ? t.indexOf(e) : 0;\n  }, r.getLabel = function (t) {\n    var e, r, n, o;\n    return [null == (e = t.locale_names) ? void 0 : e.default[this.findBestMatchLevelIndex(t._highlightResult.locale_names.default)], null == (r = t.city) ? void 0 : r.default[this.findBestMatchLevelIndex(t._highlightResult.city.default)], t.administrative[this.findBestMatchLevelIndex(t._highlightResult.administrative)], null == (n = t.postcode) ? void 0 : n[this.findBestMatchLevelIndex(t._highlightResult.postcode)], null == (o = t.country) ? void 0 : o.default].filter(Boolean).join(\", \");\n  }, r.parse = function (t) {\n    var e = this;\n    return t.data.hits.map(function (t) {\n      return {\n        x: t._geoloc.lng,\n        y: t._geoloc.lat,\n        label: e.getLabel(t),\n        bounds: null,\n        raw: t\n      };\n    });\n  }, r.search = function (t) {\n    var e = t.query;\n\n    try {\n      var r = this,\n          n = \"string\" == typeof e ? {\n        query: e\n      } : e;\n      return Promise.resolve(fetch(r.endpoint(), {\n        method: \"POST\",\n        body: JSON.stringify(u({}, r.options.params, {}, n))\n      })).then(function (t) {\n        return Promise.resolve(t.json()).then(function (t) {\n          return r.parse({\n            data: t\n          });\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(S),\n    q = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://dev.virtualearth.net/REST/v1/Locations\", e;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        r = \"string\" == typeof e ? {\n      q: e\n    } : e;\n    return r.jsonp = t.jsonp, this.getUrl(this.searchUrl, r);\n  }, r.parse = function (t) {\n    return 0 === t.data.resourceSets.length ? [] : t.data.resourceSets[0].resources.map(function (t) {\n      return {\n        x: t.point.coordinates[1],\n        y: t.point.coordinates[0],\n        label: t.address.formattedAddress,\n        bounds: [[t.bbox[0], t.bbox[1]], [t.bbox[2], t.bbox[3]]],\n        raw: t\n      };\n    });\n  }, r.search = function (t) {\n    var e,\n        r,\n        n,\n        o = t.query;\n\n    try {\n      var s = this,\n          i = \"BING_JSONP_CB_\" + Date.now();\n      return Promise.resolve((e = s.endpoint({\n        query: o,\n        jsonp: i\n      }), r = i, n = f(\"script\", null, document.body), n.setAttribute(\"type\", \"text/javascript\"), new Promise(function (t) {\n        window[r] = function (e) {\n          n.remove(), delete window[r], t(e);\n        }, n.setAttribute(\"src\", e);\n      }))).then(function (t) {\n        return s.parse({\n          data: t\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(S),\n    N = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/find\", e;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        r = \"string\" == typeof e ? {\n      text: e\n    } : e;\n    return r.f = \"json\", this.getUrl(this.searchUrl, r);\n  }, r.parse = function (t) {\n    return t.data.locations.map(function (t) {\n      return {\n        x: t.feature.geometry.x,\n        y: t.feature.geometry.y,\n        label: t.name,\n        bounds: [[t.extent.ymin, t.extent.xmin], [t.extent.ymax, t.extent.xmax]],\n        raw: t\n      };\n    });\n  }, e;\n}(S),\n    A = function (t) {\n  function e(e) {\n    var r;\n    return void 0 === e && (e = {}), (r = t.call(this, e) || this).host = e.host || \"http://localhost:4000\", r;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query;\n\n    switch (t.type) {\n      case g.REVERSE:\n        return this.getUrl(this.host + \"/v1/reverse\", \"string\" == typeof e ? {} : e);\n\n      default:\n        return this.getUrl(this.host + \"/v1/autocomplete\", \"string\" == typeof e ? {\n          text: e\n        } : e);\n    }\n  }, r.parse = function (t) {\n    return t.data.features.map(function (t) {\n      var e = {\n        x: t.geometry.coordinates[0],\n        y: t.geometry.coordinates[1],\n        label: t.properties.label,\n        bounds: null,\n        raw: t\n      };\n      return Array.isArray(t.bbox) && 4 === t.bbox.length && (e.bounds = [[t.bbox[1], t.bbox[0]], [t.bbox[3], t.bbox[2]]]), e;\n    });\n  }, e;\n}(S),\n    M = function (t) {\n  function e(e) {\n    return void 0 === e && (e = {}), e.host = \"https://api.geocode.earth\", t.call(this, e) || this;\n  }\n\n  return l(e, t), e;\n}(A),\n    F = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://maps.googleapis.com/maps/api/geocode/json\", e;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query;\n    return this.getUrl(this.searchUrl, \"string\" == typeof e ? {\n      address: e\n    } : e);\n  }, r.parse = function (t) {\n    return t.data.results.map(function (t) {\n      return {\n        x: t.geometry.location.lng,\n        y: t.geometry.location.lat,\n        label: t.formatted_address,\n        bounds: [[t.geometry.viewport.southwest.lat, t.geometry.viewport.southwest.lng], [t.geometry.viewport.northeast.lat, t.geometry.viewport.northeast.lng]],\n        raw: t\n      };\n    });\n  }, e;\n}(S),\n    _ = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://geocode.search.hereapi.com/v1/geocode\", e;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query;\n    return this.getUrl(this.searchUrl, \"string\" == typeof e ? {\n      q: e\n    } : e);\n  }, r.parse = function (t) {\n    return t.data.items.map(function (t) {\n      return {\n        x: t.position.lng,\n        y: t.position.lat,\n        label: t.address.label,\n        bounds: null,\n        raw: t\n      };\n    });\n  }, e;\n}(S),\n    B = function (t) {\n  function e(e) {\n    var r;\n    void 0 === e && (e = {});\n    var n = \"https://nominatim.openstreetmap.org\";\n    return (r = t.call(this, e) || this).searchUrl = e.searchUrl || n + \"/search\", r.reverseUrl = e.reverseUrl || n + \"/reverse\", r;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        r = t.type,\n        n = \"string\" == typeof e ? {\n      q: e\n    } : e;\n\n    switch (n.format = \"json\", r) {\n      case g.REVERSE:\n        return this.getUrl(this.reverseUrl, n);\n\n      default:\n        return this.getUrl(this.searchUrl, n);\n    }\n  }, r.parse = function (t) {\n    return (Array.isArray(t.data) ? t.data : [t.data]).map(function (t) {\n      return {\n        x: Number(t.lon),\n        y: Number(t.lat),\n        label: t.display_name,\n        bounds: [[parseFloat(t.boundingbox[0]), parseFloat(t.boundingbox[2])], [parseFloat(t.boundingbox[1]), parseFloat(t.boundingbox[3])]],\n        raw: t\n      };\n    });\n  }, e;\n}(S),\n    O = function (t) {\n  function e(e) {\n    return t.call(this, u({}, e, {\n      searchUrl: \"https://locationiq.org/v1/search.php\",\n      reverseUrl: \"https://locationiq.org/v1/reverse.php\"\n    })) || this;\n  }\n\n  return l(e, t), e;\n}(B),\n    I = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://api.opencagedata.com/geocode/v1/json\", e;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        r = \"string\" == typeof e ? {\n      q: e\n    } : e;\n    return r.format = \"json\", this.getUrl(this.searchUrl, r);\n  }, r.parse = function (t) {\n    return t.data.results.map(function (t) {\n      return {\n        x: t.geometry.lng,\n        y: t.geometry.lat,\n        label: t.formatted,\n        bounds: [[t.bounds.southwest.lat, t.bounds.southwest.lng], [t.bounds.northeast.lat, t.bounds.northeast.lng]],\n        raw: t\n      };\n    });\n  }, r.search = function (e) {\n    try {\n      return Promise.resolve(e.query.length < 2 ? [] : t.prototype.search.call(this, e));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(S),\n    D = function (t) {\n  function e(e) {\n    var r;\n    return void 0 === e && (e = {}), (r = t.call(this, e) || this).searchUrl = e.searchUrl || \"https://a.tiles.mapbox.com/v4/geocode/mapbox.places/\", r;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    return this.getUrl(\"\" + this.searchUrl + t.query + \".json\");\n  }, r.parse = function (t) {\n    return (Array.isArray(t.data.features) ? t.data.features : []).map(function (t) {\n      var e = null;\n      return t.bbox && (e = [[parseFloat(t.bbox[1]), parseFloat(t.bbox[0])], [parseFloat(t.bbox[3]), parseFloat(t.bbox[2])]]), {\n        x: Number(t.center[0]),\n        y: Number(t.center[1]),\n        label: t.place_name ? t.place_name : t.text,\n        bounds: e,\n        raw: t\n      };\n    });\n  }, e;\n}(S),\n    V = function (t) {\n  function e(e) {\n    var r;\n    void 0 === e && (e = {});\n    var n = \"https://api-adresse.data.gouv.fr\";\n    return (r = t.call(this, e) || this).searchUrl = e.searchUrl || n + \"/search\", r.reverseUrl = e.reverseUrl || n + \"/reverse\", r;\n  }\n\n  l(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        r = \"string\" == typeof e ? {\n      q: e\n    } : e;\n\n    switch (t.type) {\n      case g.REVERSE:\n        return this.getUrl(this.reverseUrl, r);\n\n      default:\n        return this.getUrl(this.searchUrl, r);\n    }\n  }, r.parse = function (t) {\n    return t.data.features.map(function (t) {\n      return {\n        x: t.geometry.coordinates[0],\n        y: t.geometry.coordinates[1],\n        label: t.properties.label,\n        bounds: null,\n        raw: t\n      };\n    });\n  }, e;\n}(S);\n\nexport { j as AlgoliaProvider, q as BingProvider, N as EsriProvider, V as GeoApiFrProvider, R as GeoSearchControl, M as GeocodeEarthProvider, F as GoogleProvider, _ as HereProvider, S as JsonProvider, O as LocationIQProvider, D as MapBoxProvider, I as OpenCageProvider, B as OpenStreetMapProvider, A as PeliasProvider, R as SearchControl, L as SearchElement }; //# sourceMappingURL=geosearch.module.js.map","map":null,"metadata":{},"sourceType":"module"}